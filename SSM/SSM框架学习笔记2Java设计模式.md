# Java设计模式

### Java反射

* 在Java中，反射是通过包java. lang . reflect,*来实现的

* 反射机制：在运行状态中，对任意一个类都能知道该类所有属性和方法，且对任意一个对象，都能调用它的任意一个方法（动态获取信息及动态调用对象方法）

### 动态代理模式和责任链模式

#### 代理模式

* 代理作用：在真实对象访问之前或之后加入对应的逻辑，或根据其他规则决定是否使用真实对象
* 调用者-->代理对象-->真实对象
* 代理步骤
  * 代理对象和真实对相关建立代理关系
  * 实现代理对象的代理逻辑方法

* 常用动态代理：JDK和CGLIB

#### JDK动态代理

客户--公司商务--工程师案例

* 需借助接口产生代理对象，先定义接口
* 建立代理对象与真实对象之间的关系，用bind方法，生成代理对象proxy
* 实现代理逻辑，用invoke方法，包含3个参数，控制真实对象的访问
  * proxy 代理对象，bind方法生成对象
  * method 当前调度的方法
  * args 调度方法的参数

* 代理对象调用真实对象的方法时会进入到invoke方法（代理逻辑方法）中，在根据invoke内容判断是否调用真实对象的方法

#### CGLIB动态代理

* 不需要提供接口，只要一个非抽象类
* 通过getProxy方法生成代理对象
* 通过intercept实现代理逻辑方法决定是否调用真实对象方法

#### 拦截器

题外话：System.err.println()与System.out.println()的区别

* out为标准输出流，带有缓存，由JVM和操作系统共同决定何时输出

* err为标准错误输出流，不带缓存，直接输出

程序设计者会设计拦截器接口供开发者使用，开发者只要知道拦截器接口方法、含义和作用即可

无须知道动态代理是怎么实现的

```
* 拦截器工作流程
* 1 bind方法用JDK动态代理绑定对象，返回代理对象
* 2 如果没有设置拦截器，则直接反射真实对象的方法，然后结束。否则进行步骤3
* 3 通过反射生成拦截器，并准备使用它
* 4 调用拦截器的before方法，若返回true，反射原来的方法，否则运行拦截器的around方法
* 5 调用拦截器的after方法
* 6 返回结果
```

#### 责任链模式

员工请假案例--三重审核

* 责任链模式：一个对象在一条链上被多个拦截器拦截处理，这样的设计模式成为责任链模式
* 用于一个对象在多个角色中传递的场景

* 拦截器的before方法按照最后一个拦截器到第一个拦截器的加载顺序运行
* 拦截器的after方法按照从第一个拦截器到最后一个拦截器的加载顺序运行
* 优点：可在传递链上加入新的拦截器，增加拦截逻辑
* 缺点：增加代理和反射，而代理和反射的性能不高

### 观察者模式

电商产品推送案例

* 定义一对多的依赖关系，让多个观察者对象同时监视被观察者状态，

  当被观察者状态发生变化时，会通知所有观察者，并让其自动更新自己

* 观察者（监听者）---被观察者（被监听者）
* 观察者继承java.util.Observable类,实现java.util.Observable接口的update方法

### 工厂模式和抽象工厂模式

客户订购生产车辆--车厂案例

#### 普通工厂（Simple Factory）模式

* 对同属一个大类的不同类型对象，初始化有所不同，根据用户需要的产品编号来确定创建

哪种产品的对象

* 解决一类对象创建问题

#### 抽象工厂（Abstract Factory）模式

抽象工厂模式向客户端提供一个接口，使得客户端在不必指定产品的具体情况下，

创建多个产品族中的产品对象

### 建造者模式

旅游套票案例

* 建造者模式属于对象创建模式，将产品的内部属性和产品的生成过程分割开，

从而使建造过程生成具有不同内部属性的产品对象

* 分步完成对象构建，通过一步步构建信息，把一个复杂的对象构建出来